<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sankey Diagram - Merged Contract Data</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
        }

        #chart-container {
            width: 95%;
            max-width: 1200px; /* Limit max width */
            height: 75vh; /* Responsive height */
            min-height: 500px; /* Minimum height */
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative; /* For tooltip positioning */
            overflow: hidden; /* Ensure SVG fits */
        }

        #chart {
            width: 100%;
            height: 100%;
        }

        .node rect {
            cursor: pointer;
            shape-rendering: crispEdges;
            stroke: #555; /* Darker stroke for nodes */
            stroke-width: 0.5px;
            transition: fill-opacity 0.2s ease, stroke-width 0.2s ease;
        }

        .node:hover rect {
            stroke-width: 1.5px;
            stroke: #000;
        }

        .node text {
            pointer-events: none;
            text-shadow: 0 1px 0 #fff;
            fill: #222; /* Darker text for better contrast */
            font-size: 10px;
            font-weight: 500;
        }

        .link {
            fill: none;
            stroke-opacity: 0.3; /* Default link opacity */
            transition: stroke-opacity 0.2s ease;
        }

        .link:hover {
            stroke-opacity: 0.6; /* Highlighted link opacity */
        }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none; /* Tooltip shouldn't block interactions */
            opacity: 0;
            transition: opacity 0.2s ease;
            white-space: nowrap;
            z-index: 10;
        }

        #tooltip.visible {
            opacity: 1;
        }

        #tooltip h4 {
            margin: 0 0 5px 0;
            font-size: 13px;
        }

        #tooltip p {
            margin: 3px 0;
        }

        #loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #666;
        }

        /* Basic responsive adjustments */
        @media (max-width: 768px) {
            body {
                margin: 10px;
            }
            h1 {
                font-size: 1.5em;
            }
            #chart-container {
                height: 65vh;
                min-height: 400px;
            }
             .node text {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <h1>Sankey Diagram: Merged Contract Data Flow</h1>
    <div id="chart-container">
        <div id="loading">Loading data...</div>
        <div id="chart"></div>
        <div id="tooltip"></div>
    </div>

    <script>
        // --- Configuration ---
        const dataUrl = "testmanyrows_filtered.csv"; // Path to your merged CSV file
        const valueField = 'subaward_amount'; // Field containing the value for links
        const nodeColorScale = d3.scaleOrdinal(d3.schemeCategory10); // Color scale for node types

        // --- Helper Functions ---
        function formatCurrency(value) {
            if (typeof value !== 'number' || isNaN(value)) return '$?';
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(value);
        }

        function showTooltip(event, content) {
            const tooltip = d3.select('#tooltip');
            tooltip.html(content)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .classed('visible', true);
        }

        function hideTooltip() {
            d3.select('#tooltip').classed('visible', false);
        }

        // --- Data Processing ---
        function processDataForSankey(data) {
            console.log(`Processing ${data.length} rows for Sankey...`);
            const nodesMap = new Map(); // Use Map for efficient node lookup { id -> nodeObject }
            const linksMap = new Map(); // Use Map to aggregate link values { 'sourceId|targetId' -> linkObject }

            data.forEach(row => {
                // Extract hierarchy levels - use fallback fields if primary is missing
                const agencyName = row.prime_award_awarding_agency_name?.trim() || row.awarding_agency_name?.trim();
                const subAgencyName = row.prime_award_awarding_sub_agency_name?.trim() || row.awarding_sub_agency_name?.trim();
                const officeName = row.prime_award_awarding_office_name?.trim() || row.awarding_office_name?.trim();
                const primeName = row.prime_awardee_name?.trim() || row.recipient_name?.trim();
                const subName = row.subawardee_name?.trim(); // This might be null/empty

                // Get the value for this specific row (subaward amount)
                const value = parseFloat(String(row[valueField] || '0').replace(/[^0-9.-]+/g, '')) || 0;

                // Skip row if essential hierarchy is missing or value is invalid/zero
                // Only require subName if it's expected to exist (i.e., value > 0)
                if (!agencyName || !subAgencyName || !officeName || !primeName || value <= 0 || !subName) {
                    return; // Skip this row if it doesn't represent a valid subaward link
                }

                // Define node IDs
                const agencyId = `agency-${agencyName}`;
                const subAgencyId = `subagency-${subAgencyName}`;
                const officeId = `office-${officeName}`;
                const primeId = `prime-${primeName}`;
                const subId = `sub-${subName}`;

                // Add/Update nodes (value aggregation isn't strictly needed for Sankey nodes, but can be useful)
                if (!nodesMap.has(agencyId)) nodesMap.set(agencyId, { id: agencyId, name: agencyName, type: 'agency', value: 0 });
                if (!nodesMap.has(subAgencyId)) nodesMap.set(subAgencyId, { id: subAgencyId, name: subAgencyName, type: 'subagency', value: 0 });
                if (!nodesMap.has(officeId)) nodesMap.set(officeId, { id: officeId, name: officeName, type: 'office', value: 0 });
                if (!nodesMap.has(primeId)) nodesMap.set(primeId, { id: primeId, name: primeName, type: 'prime', value: 0 });
                if (!nodesMap.has(subId)) nodesMap.set(subId, { id: subId, name: subName, type: 'sub', value: 0 });

                // Accumulate value on nodes if desired (optional for basic Sankey)
                nodesMap.get(agencyId).value += value;
                nodesMap.get(subAgencyId).value += value;
                nodesMap.get(officeId).value += value;
                nodesMap.get(primeId).value += value;
                nodesMap.get(subId).value += value;

                // Add/Update links (aggregate value)
                const linksToAdd = [
                    { source: agencyId, target: subAgencyId, type: 'agencyToSub' },
                    { source: subAgencyId, target: officeId, type: 'subToOffice' },
                    { source: officeId, target: primeId, type: 'officeToPrime' },
                    { source: primeId, target: subId, type: 'primeToSub' }
                ];

                linksToAdd.forEach(linkInfo => {
                    const linkKey = `${linkInfo.source}|${linkInfo.target}`;
                    if (!linksMap.has(linkKey)) {
                        linksMap.set(linkKey, {
                            source: linkInfo.source,
                            target: linkInfo.target,
                            value: 0,
                            type: linkInfo.type // Store link type if needed
                        });
                    }
                    linksMap.get(linkKey).value += value;
                });
            });

            const nodes = Array.from(nodesMap.values());
            const links = Array.from(linksMap.values());

            console.log(`Processed into ${nodes.length} nodes and ${links.length} links.`);
            // Filter out nodes that might have ended up with zero value if necessary
            // Filter out links with zero value
            const finalNodes = nodes; //.filter(n => n.value > 0); // Keep all nodes for structure
            const finalLinks = links.filter(l => l.value > 0);

            // Ensure all nodes referenced by links exist in the nodes list
            const finalNodeIds = new Set(finalNodes.map(n => n.id));
            const validLinks = finalLinks.filter(l => finalNodeIds.has(l.source) && finalNodeIds.has(l.target));

            console.log(`Final valid data: ${finalNodes.length} nodes, ${validLinks.length} links.`);
            return { nodes: finalNodes, links: validLinks };
        }


        // --- Drawing Function ---
        function drawSankeyDiagram(data) {
            const chartElement = d3.select('#chart');
            chartElement.html(''); // Clear previous chart or loading message

            if (!data || !data.nodes || !data.links || data.nodes.length === 0 || data.links.length === 0) {
                chartElement.html('<div id="loading">No data matches the criteria for the Sankey diagram.</div>');
                console.warn("drawSankeyDiagram: No valid data to draw.");
                return;
            }

            const chartContainer = document.getElementById('chart');
            const containerRect = chartContainer.getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 }; // Add some margins
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            if (innerWidth <= 0 || innerHeight <= 0) {
                chartElement.html('<div id="loading">Chart container is too small.</div>');
                console.error("Chart container invalid dimensions.");
                return;
            }

            const svg = chartElement.append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create Sankey layout generator
            const sankey = d3.sankey()
                .nodeId(d => d.id) // Use the unique ID we created
                .nodeWidth(15)
                .nodePadding(10)
                .nodeAlign(d3.sankeyLeft) // Align nodes to the left
                .extent([[0, 0], [innerWidth, innerHeight]]);

            // Compute the Sankey layout
            let graph;
            try {
                 // Need to deep copy data as sankey mutates it
                 const graphDataCopy = {
                     nodes: data.nodes.map(d => ({...d})),
                     links: data.links.map(d => ({...d}))
                 };
                graph = sankey(graphDataCopy);
            } catch (e) {
                console.error("Error calculating Sankey layout:", e);
                chartElement.html(`<div id="loading">Error calculating layout: ${e.message}.</div>`);
                return;
            }


            // --- Draw Links ---
            const link = svg.append("g")
                .attr("class", "links")
                .attr("fill", "none")
                .attr("stroke", "#aaa") // Default link color
                .selectAll("path")
                .data(graph.links)
                .join("path")
                .attr("class", "link")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke-width", d => Math.max(1, d.width))
                .style("stroke-opacity", 0.3) // Use style for opacity
                .sort((a, b) => b.width - a.width) // Draw thicker links on top
                .on("mouseover", function(event, d) {
                    d3.select(this).style("stroke-opacity", 0.6);
                    const content = `<h4>${d.source.name} â†’ ${d.target.name}</h4><p>Value: ${formatCurrency(d.value)}</p>`;
                    showTooltip(event, content);
                })
                .on("mouseout", function() {
                    d3.select(this).style("stroke-opacity", 0.3);
                    hideTooltip();
                });

            // --- Draw Nodes ---
            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(graph.nodes)
                .join("g")
                .attr("class", d => `node node-type-${d.type}`)
                .attr("transform", d => `translate(${d.x0},${d.y0})`);

            node.append("rect")
                .attr("height", d => Math.max(0.5, d.y1 - d.y0)) // Ensure positive height
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", d => nodeColorScale(d.type)) // Color by node type
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("stroke", "#000"); // Add stroke on hover
                    const content = `<h4>${d.name}</h4><p>Type: ${d.type}</p><p>Total Flow: ${formatCurrency(d.value)}</p>`;
                    showTooltip(event, content);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("stroke", "#555"); // Reset stroke
                    hideTooltip();
                });

            // --- Add Node Labels ---
            node.append("text")
                .attr("x", d => d.x0 < innerWidth / 2 ? 6 + (d.x1 - d.x0) : -6) // Position right or left
                .attr("y", d => (d.y1 - d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < innerWidth / 2 ? "start" : "end")
                .text(d => d.name)
                .filter(d => d.x0 < innerWidth / 2) // Filter for labels on the left
                .attr("x", 6 + (d => d.x1 - d.x0)) // Adjust position for left-aligned labels
                .attr("text-anchor", "start");

            console.log("Sankey diagram drawn.");
        }

        // --- Load Data and Initialize ---
        d3.csv(dataUrl)
            .then(loadedData => {
                document.getElementById('loading').style.display = 'none'; // Hide loading message
                if (!loadedData || loadedData.length === 0) {
                    throw new Error("CSV file loaded successfully, but it contains no data rows.");
                }
                const processed = processDataForSankey(loadedData);
                drawSankeyDiagram(processed);
            })
            .catch(error => {
                console.error("Error loading or processing data:", error);
                document.getElementById('loading').innerHTML = `Error loading data: ${error.message}. Please check the file path and format.`;
                document.getElementById('loading').style.color = 'red';
            });

        // Optional: Redraw on window resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                 d3.csv(dataUrl).then(loadedData => { // Reload data on resize for simplicity
                     if (loadedData && loadedData.length > 0) {
                        const processed = processDataForSankey(loadedData);
                        drawSankeyDiagram(processed);
                     }
                 }).catch(e => console.error("Resize redraw error:", e));
             }, 250); // Debounce resize event
         });

    </script>
</body>
</html>
