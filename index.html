<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QBR Sankey Diagram - Full Hierarchy (Filtered)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #212529;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            text-align: center;
            color: #343a40;
            margin-bottom: 15px;
        }

        /* Filter Controls Styling */
        #filter-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 8px;
            width: 95%;
            max-width: 800px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .filter-group label {
            font-size: 0.85em;
            color: #495057;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .filter-group input[type="range"],
        .filter-group select {
            padding: 5px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.9em;
        }
         .filter-group input[type="range"] {
             width: 180px;
             cursor: pointer;
         }
         .filter-group select {
             min-width: 120px;
         }

        #min-value-display {
            font-weight: bold;
            color: #007bff;
            margin-left: 5px;
            min-width: 60px;
            display: inline-block;
            text-align: right;
        }
         .filter-group#min-value-group label {
             display: flex;
             align-items: center;
         }


        #chart-container {
            width: 95%;
            max-width: 1300px;
            height: 70vh;
            min-height: 500px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }

        #chart {
            width: 100%;
            height: 100%;
        }

        /* Node Styling */
        .node rect {
            cursor: pointer;
            shape-rendering: crispEdges;
            stroke: #ffffff;
            stroke-width: 1px;
            transition: fill-opacity 0.2s ease, stroke-width 0.2s ease, stroke 0.2s ease;
            rx: 2px;
            ry: 2px;
        }

        .node:hover rect {
            stroke-width: 2px;
            stroke: #007bff;
            fill-opacity: 1;
        }

        /* Specific Node Type Colors - Updated */
        .node-type-agency rect { fill: #663399; }    /* Rebeccapurple */
        .node-type-subagency rect { fill: #8A2BE2; } /* Blueviolet */
        .node-type-office rect { fill: #007bff; }    /* Blue */
        .node-type-prime rect { fill: #17a2b8; }    /* Info Blue */
        .node-type-sub rect { fill: #28a745; }     /* Green */

        .node text {
            pointer-events: none;
            fill: #343a40;
            font-size: 10px; /* Slightly smaller for more levels */
            font-weight: 500;
            text-shadow: 0 1px 1px rgba(255,255,255,0.7);
        }

        /* Link Styling */
        .link {
            fill: none;
            stroke-opacity: 0.3; /* Slightly lower opacity for more links */
            transition: stroke-opacity 0.2s ease;
        }

        .link:hover {
            stroke-opacity: 0.6;
        }

        /* Tooltip Styling */
        #tooltip {
            position: absolute;
            background-color: rgba(40, 40, 40, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            white-space: nowrap;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #tooltip.visible {
            opacity: 1;
        }

        #tooltip h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            border-bottom: 1px solid #666;
            padding-bottom: 4px;
        }

        #tooltip p {
            margin: 4px 0;
        }
        #tooltip strong {
            color: #a2d2ff;
        }

        #loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #6c757d;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body { padding: 10px; }
            h1 { font-size: 1.3em; } /* Adjusted */
            #filter-controls { flex-direction: column; align-items: stretch; gap: 15px; }
            .filter-group { width: 100%; }
            .filter-group input[type="range"] { width: calc(100% - 16px); }
            #chart-container { height: 65vh; min-height: 400px; }
            .node text { font-size: 9px; }
            #tooltip { font-size: 12px; padding: 8px 12px; }
        }
         @media (max-width: 480px) {
             h1 { font-size: 1.1em; } /* Adjusted */
         }
    </style>
</head>
<body>
    <h1>Contract Flow: Agency → SubAgency → Office → Prime → Subcontractor</h1> {/* Updated Title */}

    <div id="filter-controls">
        <div class="filter-group" id="min-value-group">
            <label for="min-value-slider">Min Subaward Value: <span id="min-value-display">$0K</span></label>
            <input type="range" id="min-value-slider" name="min-value" min="0" max="1000000" step="50000" value="0">
        </div>
        <div class="filter-group">
            <label for="top-n-select">Show Contracts:</label>
            <select id="top-n-select" name="top-n">
                <option value="0">Show All</option>
                <option value="10">Top 10</option>
                <option value="20">Top 20</option>
                <option value="50">Top 50</option>
                <option value="100">Top 100</option>
            </select>
        </div>
    </div>

    <div id="chart-container">
        <div id="loading">Loading data...</div>
        <div id="chart"></div>
        <div id="tooltip"></div>
    </div>

    <script>
        // --- Global Variables ---
        const dataUrl = "testmanyrows_filtered.csv";
        const valueField = 'subaward_amount';
        const qbrColorScale = d3.scaleOrdinal()
            .domain(['agency', 'subagency', 'office', 'prime', 'sub'])
            .range(['#663399', '#8A2BE2', '#007bff', '#17a2b8', '#28a745']);

        let rawData = [];
        let currentMinValue = 0;
        let currentTopN = 0;
        let minValueDebounceTimer;
        let resizeTimer;

        // --- DOM Elements ---
        const minValueSlider = document.getElementById('min-value-slider');
        const minValueDisplay = document.getElementById('min-value-display');
        const topNSelect = document.getElementById('top-n-select');
        const loadingDiv = document.getElementById('loading');
        const chartDiv = d3.select('#chart');
        const tooltipDiv = d3.select('#tooltip');


        // --- Helper Functions ---
        function formatCurrency(value, useSuffix = true) { /* ... as before ... */
            if (typeof value !== 'number' || isNaN(value)) return '$?';
            if (useSuffix) {
                if (Math.abs(value) >= 1e9) return `$${(value / 1e9).toFixed(1)}B`;
                if (Math.abs(value) >= 1e6) return `$${(value / 1e6).toFixed(1)}M`;
                if (Math.abs(value) >= 1e3) return `$${(value / 1e3).toFixed(0)}K`;
            }
            return new Intl.NumberFormat('en-US', {
                style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0
            }).format(value);
        }
        function showTooltip(event, content) { /* ... as before ... */
             tooltipDiv.html(content)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .classed('visible', true);
        }
        function hideTooltip() { /* ... as before ... */
             tooltipDiv.classed('visible', false);
        }

        // --- Data Processing (Handles Full Hierarchy & Top N - CORRECTED) ---
        function processDataForSankey(data, topN) {
            console.log(`Processing ${data.length} raw rows for Sankey. Top N = ${topN}`);
            const nodesMap = new Map(); // Stores ALL potential nodes initially {id -> nodeObject}
            const primeToSubLinksRaw = []; // Store raw P->S links with hierarchy info

            // --- Pass 1: Collect all potential nodes and raw P->S links ---
            data.forEach(row => {
                const agencyName = row.prime_award_awarding_agency_name?.trim() || row.awarding_agency_name?.trim();
                const subAgencyName = row.prime_award_awarding_sub_agency_name?.trim() || row.awarding_sub_agency_name?.trim();
                const officeName = row.prime_award_awarding_office_name?.trim() || row.awarding_office_name?.trim();
                const primeName = row.prime_awardee_name?.trim() || row.recipient_name?.trim();
                const subName = row.subawardee_name?.trim();
                const value = parseFloat(String(row[valueField] || '0').replace(/[^0-9.-]+/g, '')) || 0;

                // Skip if essential info is missing or value <= 0, MUST have a sub for this flow
                if (!agencyName || !subAgencyName || !officeName || !primeName || !subName || value <= 0) {
                    return;
                }

                // Define node IDs
                const agencyId = `agency-${agencyName}`;
                const subAgencyId = `subagency-${subAgencyName}`;
                const officeId = `office-${officeName}`;
                const primeId = `prime-${primeName}`;
                const subId = `sub-${subName}`;

                // Add/Update nodes (value will be recalculated later)
                if (!nodesMap.has(agencyId)) nodesMap.set(agencyId, { id: agencyId, name: agencyName, type: 'agency', value: 0 });
                if (!nodesMap.has(subAgencyId)) nodesMap.set(subAgencyId, { id: subAgencyId, name: subAgencyName, type: 'subagency', value: 0 });
                if (!nodesMap.has(officeId)) nodesMap.set(officeId, { id: officeId, name: officeName, type: 'office', value: 0 });
                if (!nodesMap.has(primeId)) nodesMap.set(primeId, { id: primeId, name: primeName, type: 'prime', value: 0 });
                if (!nodesMap.has(subId)) nodesMap.set(subId, { id: subId, name: subName, type: 'sub', value: 0 });

                // Store raw P->S link with hierarchy IDs for filtering and aggregation
                primeToSubLinksRaw.push({
                    agencyId, subAgencyId, officeId, primeId, subId, value
                });
            });

            let finalNodes = [];
            let finalLinks = [];
            let relevantPrimeSubLinks = primeToSubLinksRaw; // Start with all valid P->S links

            // --- Apply Top N Filter (if applicable) ---
            if (topN > 0 && primeToSubLinksRaw.length > 0) {
                console.log(`Applying Top ${topN} filter...`);
                primeToSubLinksRaw.sort((a, b) => b.value - a.value); // Sort descending by value
                relevantPrimeSubLinks = primeToSubLinksRaw.slice(0, topN); // Keep only top N raw links
            }

            // --- Pass 2: Aggregate links and identify nodes based on relevant P->S links ---
            const finalLinksMap = new Map(); // { 'sourceId|targetId' -> linkObject }
            const finalNodesInFlow = new Set();

            relevantPrimeSubLinks.forEach(rawLink => {
                // Add nodes involved in this link to the final set
                finalNodesInFlow.add(rawLink.agencyId);
                finalNodesInFlow.add(rawLink.subAgencyId);
                finalNodesInFlow.add(rawLink.officeId);
                finalNodesInFlow.add(rawLink.primeId);
                finalNodesInFlow.add(rawLink.subId);

                // Aggregate link values
                const linksToUpdate = [
                    { key: `${rawLink.agencyId}|${rawLink.subAgencyId}`, source: rawLink.agencyId, target: rawLink.subAgencyId, type: 'agencyToSub' },
                    { key: `${rawLink.subAgencyId}|${rawLink.officeId}`, source: rawLink.subAgencyId, target: rawLink.officeId, type: 'subToOffice' },
                    { key: `${rawLink.officeId}|${rawLink.primeId}`, source: rawLink.officeId, target: rawLink.primeId, type: 'officeToPrime' },
                    { key: `${rawLink.primeId}|${rawLink.subId}`, source: rawLink.primeId, target: rawLink.subId, type: 'primeToSub' }
                ];

                linksToUpdate.forEach(linkInfo => {
                    if (!finalLinksMap.has(linkInfo.key)) {
                        finalLinksMap.set(linkInfo.key, {
                            source: linkInfo.source,
                            target: linkInfo.target,
                            value: 0,
                            type: linkInfo.type
                        });
                    }
                    finalLinksMap.get(linkInfo.key).value += rawLink.value; // Aggregate value
                });
            });

            // Filter the initial nodesMap to keep only those involved in the flow
            finalNodes = Array.from(nodesMap.values()).filter(node => finalNodesInFlow.has(node.id));
            finalLinks = Array.from(finalLinksMap.values()).filter(link => link.value > 0); // Filter zero-value links

            // --- Pass 3: Recalculate node values based on final links ---
            finalNodes.forEach(node => node.value = 0); // Reset node values
            finalLinks.forEach(link => {
                const sourceNode = finalNodes.find(n => n.id === link.source);
                const targetNode = finalNodes.find(n => n.id === link.target);
                // Sankey node value is the max of incoming or outgoing flow for accurate sizing
                const linkValue = link.value; // Value of the current link
                if (sourceNode) {
                    const outgoingSum = d3.sum(finalLinks.filter(l => l.source === sourceNode.id), l => l.value);
                    sourceNode.value = Math.max(sourceNode.value || 0, outgoingSum);
                }
                 if (targetNode) {
                    const incomingSum = d3.sum(finalLinks.filter(l => l.target === targetNode.id), l => l.value);
                     targetNode.value = Math.max(targetNode.value || 0, incomingSum);
                 }
            });

            // Final cleanup: Remove nodes with zero value if any resulted from max calculation logic
            finalNodes = finalNodes.filter(n => n.value > 0);
            const finalNodeIds = new Set(finalNodes.map(n => n.id));
            finalLinks = finalLinks.filter(l => finalNodeIds.has(l.source) && finalNodeIds.has(l.target));


            console.log(`Processed data (Top N=${topN}): ${finalNodes.length} nodes, ${finalLinks.length} links.`);
            return { nodes: finalNodes, links: finalLinks };
        }


        // --- Drawing Function (Handles Min Value Filter) ---
        function drawSankeyDiagram(data, minValue) {
            chartDiv.html(''); // Clear previous

            if (!data || !data.nodes || !data.links) { /* ... handle error ... */ return; }

            // --- Apply Minimum Value Filter ---
            console.log(`Filtering links with value >= ${formatCurrency(minValue, false)}`);
            // Filter links based on minimum value
            const valueFilteredLinks = data.links.filter(link => link.value >= minValue);

            if (valueFilteredLinks.length === 0) { /* ... handle no links ... */
                 chartDiv.html(`<div id="loading">No contract links found above ${formatCurrency(minValue, false)}. Try lowering the minimum value filter.</div>`);
                 return;
            }

            // Identify nodes connected by the filtered links
            const nodesConnected = new Set();
            valueFilteredLinks.forEach(link => {
                nodesConnected.add(link.source);
                nodesConnected.add(link.target);
            });
            // Keep only nodes that are part of the filtered flow
            const valueFilteredNodes = data.nodes.filter(node => nodesConnected.has(node.id));

            if (valueFilteredNodes.length === 0) { /* ... handle no nodes ... */
                 chartDiv.html(`<div id="loading">No nodes connected after filtering by value >= ${formatCurrency(minValue, false)}.</div>`);
                 return;
            }
            // --- End Min Value Filter ---


            const chartContainer = document.getElementById('chart');
            const containerRect = chartContainer.getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;
            const margin = { top: 25, right: 25, bottom: 25, left: 25 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            if (innerWidth <= 10 || innerHeight <= 10) { /* ... handle small container ... */ return; }

            const svg = chartDiv.append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const sankey = d3.sankey()
                .nodeId(d => d.id)
                .nodeWidth(20)
                .nodePadding(12) // Adjusted padding
                .nodeAlign(d3.sankeyJustify) // Or d3.sankeyLeft, etc.
                .extent([[0, 0], [innerWidth, innerHeight]]);

            let graph;
            try {
                 const graphDataCopy = {
                     nodes: valueFilteredNodes.map(d => ({...d})), // Use filtered nodes
                     links: valueFilteredLinks.map(d => ({...d})) // Use filtered links
                 };
                 // Recalculate node values based *only* on the filtered links before layout
                 graphDataCopy.nodes.forEach(node => node.value = 0); // Reset values
                 graphDataCopy.links.forEach(link => {
                     const sourceNode = graphDataCopy.nodes.find(n => n.id === link.source);
                     const targetNode = graphDataCopy.nodes.find(n => n.id === link.target);
                     // Use max of incoming/outgoing for node value in Sankey
                     const linkValue = link.value;
                     if (sourceNode) {
                         const outgoingSum = d3.sum(graphDataCopy.links.filter(l => l.source === sourceNode.id), l => l.value);
                         sourceNode.value = Math.max(sourceNode.value || 0, outgoingSum);
                     }
                     if (targetNode) {
                         const incomingSum = d3.sum(graphDataCopy.links.filter(l => l.target === targetNode.id), l => l.value);
                         targetNode.value = Math.max(targetNode.value || 0, incomingSum);
                     }
                 });
                 // Remove nodes with zero value *after* recalculation based on filtered links
                 graphDataCopy.nodes = graphDataCopy.nodes.filter(n => n.value > 0);
                 const finalNodeIdsLayout = new Set(graphDataCopy.nodes.map(n => n.id));
                 graphDataCopy.links = graphDataCopy.links.filter(l => finalNodeIdsLayout.has(l.source) && finalNodeIdsLayout.has(l.target));


                if(graphDataCopy.nodes.length === 0 || graphDataCopy.links.length === 0) {
                     throw new Error("No nodes or links remain after final value recalculation.");
                 }
                graph = sankey(graphDataCopy);
            } catch (e) { /* ... handle layout error ... */
                 console.error("Error calculating Sankey layout:", e);
                 chartDiv.html(`<div id="loading">Layout Error: ${e.message}. Check filters.</div>`);
                 return;
             }

            // --- Draw Links ---
            const defs = svg.append("defs");
            graph.links.forEach((link, i) => { /* ... gradient definition ... */
                 const gradientId = `link-gradient-${i}`;
                 const sourceColor = qbrColorScale(link.source.type) || '#ccc';
                 const targetColor = qbrColorScale(link.target.type) || '#ccc';
                 const gradient = defs.append("linearGradient")
                     .attr("id", gradientId)
                     .attr("gradientUnits", "userSpaceOnUse")
                     .attr("x1", link.source.x1).attr("x2", link.target.x0);
                 gradient.append("stop").attr("offset", "0%").attr("stop-color", sourceColor);
                 gradient.append("stop").attr("offset", "100%").attr("stop-color", targetColor);
                 link.gradientId = gradientId;
             });

            const link = svg.append("g").attr("class", "links").attr("fill", "none")
                .selectAll("path").data(graph.links).join("path")
                .attr("class", "link")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", d => `url(#${d.gradientId})`)
                .attr("stroke-width", d => Math.max(1.5, d.width))
                .style("stroke-opacity", 0.3) // Slightly lower opacity
                .sort((a, b) => b.width - a.width)
                .on("mouseover", function(event, d) { /* ... tooltip ... */
                     d3.select(this).style("stroke-opacity", 0.6); // Adjusted hover opacity
                     const sourceTypeName = d.source.type.charAt(0).toUpperCase() + d.source.type.slice(1);
                     const targetTypeName = d.target.type.charAt(0).toUpperCase() + d.target.type.slice(1);
                     const content = `<h4>${sourceTypeName} → ${targetTypeName}</h4><p>${d.source.name} → ${d.target.name}</p><p><strong>Value:</strong> ${formatCurrency(d.value)}</p>`;
                     showTooltip(event, content);
                  })
                .on("mouseout", function() { /* ... tooltip ... */
                     d3.select(this).style("stroke-opacity", 0.3);
                     hideTooltip();
                  });

            // --- Draw Nodes ---
            const node = svg.append("g").attr("class", "nodes")
                .selectAll("g").data(graph.nodes).join("g")
                .attr("class", d => `node node-type-${d.type}`)
                .attr("transform", d => `translate(${d.x0},${d.y0})`);

            node.append("rect")
                .attr("height", d => Math.max(1, d.y1 - d.y0))
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", d => qbrColorScale(d.type)) // Use updated scale
                .attr("fill-opacity", 0.9)
                .on("mouseover", function(event, d) { /* ... tooltip ... */
                     d3.select(this).attr("stroke", "#343a40").attr("stroke-width", 2);
                     const content = `<h4>${d.name}</h4><p><strong>Type:</strong> ${d.type.charAt(0).toUpperCase() + d.type.slice(1)}</p><p><strong>Total Flow:</strong> ${formatCurrency(d.value)}</p>`;
                     showTooltip(event, content);
                 })
                .on("mouseout", function() { /* ... tooltip ... */
                     d3.select(this).attr("stroke", "#ffffff").attr("stroke-width", 1);
                     hideTooltip();
                  });

            // --- Add Node Labels ---
            node.append("text")
                .attr("x", d => d.x0 < innerWidth / 2 ? 6 + (d.x1 - d.x0) : -6)
                .attr("y", d => (d.y1 - d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < innerWidth / 2 ? "start" : "end")
                .text(d => d.name)
                .filter(d => (d.y1 - d.y0) > 10) // Adjust threshold if needed
                .clone(true).lower()
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 3)
                .attr("stroke", "#fff");

            console.log("Sankey diagram drawn with filtered data.");
        }

        // --- Filter Initialization ---
        function initializeFilters(data) { /* ... as before ... */
             const values = data.map(row => parseFloat(String(row[valueField] || '0').replace(/[^0-9.-]+/g, '')) || 0)
                              .filter(v => v > 0);
             const minValue = 0;
             const maxValue = d3.max(values) || 1000000;
             // Ensure step is reasonable, at least 10k
             const step = Math.max(10000, Math.ceil(maxValue / 100 / 10000) * 10000 || 10000);
             minValueSlider.min = minValue;
             minValueSlider.max = maxValue;
             minValueSlider.step = step;
             minValueSlider.value = currentMinValue;
             minValueDisplay.textContent = formatCurrency(currentMinValue, true);
             topNSelect.value = currentTopN;
        }

        // --- Update Chart Trigger ---
        function updateChart() { /* ... as before ... */
             console.log(`Updating chart. MinValue: ${currentMinValue}, TopN: ${currentTopN}`);
             loadingDiv.style.display = 'block';
             chartDiv.html('');
             // Process data first, applying Top N filter if selected
             const processed = processDataForSankey(rawData, currentTopN);
             // Then draw, applying the Min Value filter within the drawing function
             setTimeout(() => {
                  drawSankeyDiagram(processed, currentMinValue);
                  loadingDiv.style.display = 'none';
             }, 50);
        }


        // --- Event Listeners ---
        minValueSlider.addEventListener('input', () => { /* ... as before ... */
             const value = parseInt(minValueSlider.value);
             minValueDisplay.textContent = formatCurrency(value, true);
             clearTimeout(minValueDebounceTimer);
             minValueDebounceTimer = setTimeout(() => {
                 currentMinValue = value;
                 updateChart();
             }, 250);
        });
        topNSelect.addEventListener('change', () => { /* ... as before ... */
             currentTopN = parseInt(topNSelect.value);
             updateChart();
        });
        window.addEventListener('resize', () => { /* ... as before ... */
             clearTimeout(resizeTimer);
             resizeTimer = setTimeout(updateChart, 300);
         });


        // --- Load Data and Initialize ---
        d3.csv(dataUrl)
            .then(loadedData => { /* ... as before ... */
                 if (!loadedData || loadedData.length === 0) {
                     throw new Error("CSV file loaded, but contains no data.");
                 }
                 rawData = loadedData;
                 initializeFilters(rawData);
                 updateChart();
             })
            .catch(error => { /* ... as before ... */
                 console.error("Error loading or processing data:", error);
                 loadingDiv.innerHTML = `Error: ${error.message}`;
                 loadingDiv.style.color = 'red';
             });

    </script>
</body>
</html>
